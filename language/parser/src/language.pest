element = _{ SOI ~ (structure | function)* ~ EOI }

WHITESPACE = _{ (" " | "\n" | "\r" | "\t")+ }
COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

ident = { ASCII_ALPHANUMERIC+ }

public = { "pub" }
static_mod = { "static" }
extern_mod = { "extern" }
modifiers = { public? ~ static_mod? ~ extern_mod? }

structure = { "struct" ~ ident ~ "{" ~ (struct_field|function)* ~ "}"}
struct_field = { modifiers ~ field ~ ";" }

field = { ident ~ ":" ~ ident }
fields = { (field ~ ",")* ~ field? }
return_type = _{ "->" ~ ident }
function = { modifiers ~ "fn" ~ ident ~ "(" ~ fields ~ ")" ~ return_type? ~ code_block }

code_block = { "{" ~ line* ~ "}" }

line = _{ escape_statement | (expression ~ ";") | block }

expression = { term ~ effect* }

block = { if_statement | for_statement }
if_statement = { "if" ~ expression ~ code_block }
for_statement = { "for" ~ ident ~ "in" ~ expression ~ code_block }

// Wrapped for some parsing cases
wrapped_effect = { effect }

effect = _{ method | math | index | block | range | paren_effect }
term = { assign | terms }

terms = { string | number | ident | term_math }
paren_effect = _{ "(" ~ effect ~ ")" }

equals = { "=" }
range = { term ~ effect* ~ ".." ~ effect }
index = { "[" ~ effect ~ "]" }
assign = { "let" ~ ident ~ assign_type? ~ "=" ~ wrapped_effect }
assign_type = { ":" ~ ident }

escape_statement = { (returning|block_return) ~ wrapped_effect? ~ ";" }
returning = { "return" }
block_return = { "break" }

method = { "."? ~ ident ~ arguments }

arguments = { "(" ~ (expression ~ ",")* ~ expression? ~ ")" }

negative = @{"-"}

string = @{ "\"" ~ ANY+ ~ "\"" }
digits = @{ ASCII_DIGIT+ }
integer = @{ negative? ~ digits }
float = @{ negative? ~ digits ~ "." ~ digits }

number = _{ integer | float }
addition = { "+" }
subtraction = { "-" }
multiplication = { "*" }
division = { "/" }

negate = { subtraction ~ number }
operation = _{ addition | subtraction | multiplication | division }
math = { operation ~ wrapped_effect }
term_math = { (negate) ~ term }