import numbers;

// Defines an equality operator, which takes two arguments.
// It has a priority of -1 (0 is addition/subtraction)
// Types can implement this trait to implement the operator.
#[priority(-1)]
#[operation({}=={})]
trait Equal<T> {
    fn equal(self, other: T) -> bool;
}

#[priority(-1)]
#[operation({}!={})]
trait NotEqual<T> {
    fn not_equal(self, other: T) -> bool;
}

#[priority(4)]
#[operation(!{})]
trait Not<T> {
    fn not(self) -> T;
}

#[priority(1)]
#[operation({}+{})]
trait Add<E, C> {
    fn add(self, other: E) -> C;
}

#[priority(1)]
#[operation({}+={})]
trait AddAndAssign<E, C> {
    fn add_assign(self, other: E) -> C;
}

#[priority(1)]
#[operation({}-{})]
trait Subtract<E, C> {
    fn subtract(self, other: E) -> C;
}

#[priority(1)]
#[operation({}-={})]
trait SubtractAndAssign<E, C> {
    fn subtract_assign(self, other: E) -> C;
}

#[priority(2)]
#[operation({}*{})]
trait Multiply<E, C> {
    fn multiply(self, other: E) -> C;
}

#[priority(1)]
#[operation({}*={})]
trait MultiplyAndAssign<E, C> {
    fn multiply_assign(self, other: E) -> C;
}

#[priority(2)]
#[operation({}/{})]
trait Divide<E, C> {
    fn divide(self, other: E) -> C;
}

#[priority(1)]
#[operation({}/={})]
trait DivideAndAssign<E, C> {
    fn divide_assign(self, other: E) -> C;
}

#[priority(2)]
#[operation({}%{})]
trait Remainder<E, C> {
    fn remainder(self, other: E) -> C;
}

#[priority(1)]
#[operation({}%={})]
trait RemainderAndAssign<E, C> {
    fn remainder_assign(self, other: E) -> C;
}

//Basic math operations, implemented internally by the compiler.
pub internal impl<T: Number, E: Number> Equal<T> for E {
    fn equal(self, other: T) -> bool {

    }
}

pub impl<T, E: Equal<T>> NotEqual<T> for T {
    fn not_equal(self, other: E) -> bool {
        return !(other.equal(self));
    }
}

pub internal impl Not<bool> for bool {
    fn not(self) -> bool {

    }
}

//Basic math operations, implemented internally by the compiler.
pub internal impl<T: Number> Add<T, T> for T {
    fn add(self, other: T) -> T {

    }
}

pub impl<T: Add<E, C>, E, C> AddAndAssign<E, C> for T {
    fn add_assign(self, other: E) -> C {
        self = self.add(other);
        return self;
    }
}

//Basic math operations, implemented internally by the compiler.
pub internal impl<T: Number> Subtract<T, T> for T {
    fn subtract(self, other: T) -> T {

    }
}

pub impl<T: Subtract<E, C>, E, C> SubtractAndAssign<E, C> for T {
    fn subtract_assign(self, other: E) -> C {
        self = self.subtract(other);
        return self;
    }
}

//Basic math operations, implemented internally by the compiler.
pub internal impl<T: Number> Multiply<T, T> for T {
    fn multiply(self, other: T) -> T {

    }
}

pub impl<T: Multiply<E, C>, E, C> MultiplyAndAssign<E, C> for T {
    fn multiply_assign(self, other: E) -> C {
        self = self.multiply(other);
        return self;
    }
}

//Basic math operations, implemented internally by the compiler.
pub internal impl<T: Number> Divide<T, T> for T {
    fn divide(self, other: T) -> T {

    }
}

pub impl<T: Remainder<E, C>, E, C> DivideAndAssign<E, C> for T {
    fn divide_assign(self, other: E) -> C {
        self = self.divide(other);
        return self;
    }
}

//Basic math operations, implemented internally by the compiler.
pub internal impl<T: Number> Remainder<T, T> for T {
    fn remainder(self, other: T) -> T {

    }
}

pub impl<T: Remainder<E, C>, E, C> RemainderAndAssign<E, C> for T {
    fn remainder_assign(self, other: E) -> C {
        self = self.remainder(other);
        return self;
    }
}